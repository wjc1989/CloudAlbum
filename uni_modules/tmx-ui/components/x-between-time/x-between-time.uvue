<script lang="ts">
	import { type PropType } from "vue"
	import { getUid, setPagePullRefresh, getPagePullRefresh ,checkIsCssUnit} from "../../core/util/xCoreUtil.uts"
	import { getDefaultColor } from "../../core/util/xCoreColorUtil.uts"
	import { xDate, xDateTypeTime, createDate } from "../../core/util/xDate.uts"
	import { xConfig } from "../../config/xConfig.uts"
	import { PICKER_ITEM_INFO } from "../../interface.uts"
	import { DateTimeFormatOrNull} from "@/uni_modules/x-vuei18n-s/interface.uts"
	type coverValueType = {
		value : string[],
		str : string
	}

	type ModelType = "year" | "month" | "day" | "hour" | "minute" | "second";

	/**
	 * @name 时间区间选择 xBetweenTime
	 * @description 快速的时间区间选择器，方便时间选择自动判断前后时间大小并校正。
	 * @page /pages/index/between-time
	 * @category 表单组件
	 * @constant 平台兼容
	 *	| H5 | andriod | IOS | 小程序 | UTS | UNIAPP-X SDK | version |
		| --- | --- | --- | --- | --- | --- | --- |
		| ☑ | ☑️ | ☑️ | ☑️ | ☑️ | 4.44+ | 1.1.9 |
	 */
	export default {
		data() {
			let startValue = new xDate();
			let endValue = new xDate();
			startValue.subtraction(1, 'y')
			return {
				show: false,
				nowValue: ['', ''] as string[],
				nowModelValue: ['', ''] as string[],
				startDate: startValue,
				endDate: endValue,
				changeIndex: 0,

				yanchiDuration: false,
				quicklist: [] as coverValueType[],
				quicklistSelectedStr:'',
				tid:1
			}
		},
		emits: [
			/**
			 * 取消时触发
			 */
			'cancel',
			/**
			 * 确认触发
			 * @param {string} date 当前选中时间id值
			 */
			'confirm',
			/**
			 * 滑动变换时触发
			 * @param {string} date - 当前选中时间
			 */
			'change',
			/**
			 * 快速日期被选中时触发
			 * @param {UTSJSONObject<{text:string,value:string[]}>} item - 当前选中时间组
			 */
			'dateClick',
			/**
			 * 变量控制打开状态
			 * 等同v-model:model-show
			 */
			'update:modelShow',
			/**
			 * 经格式化后的值。等同v-model:model-str
			 */
			'update:modelStr',
			'update:modelValue'
		],
		props: {

			/**
			 * 当前时间,与modelStr不同，此提供的值必须是正常的时间格式
			 * 否则报错，无法运行。
			 */
			modelValue: {
				type: Array as PropType<string[]>,
				default: () : string[] => [] as string[]
			},
			/**
			 * 当前时间经过format格式化后输出的值。
			 * 此值不会处理输入，只输出显示。
			 */
			modelStr: {
				type: String,
				default: ""
			},
			/**
			 * 当前打开的状态。
			 * 等同v-model:model-show
			 */
			modelShow: {
				type: Boolean,
				default: false
			},
			/**
			 * 顶部标题
			 * 空默认为：请选择时间（根据语言不同也不同）
			 * 如果你提供了值，组件内的多语言失效以你设定的为准
			 */
			title: {
				type: String,
				default: ""
			},
			/**
			 * 开始时间，请提供正确的时间格式
			 */
			start: {
				type: String,
				default: ""
			},
			/**
			 * 结束时间，请提供正确的时间格式
			 */
			end: {
				type: String,
				default: ""
			},
			/**
			 * 精确到的级别,这里只是展示，具体的返回值还是完整的值。
			 * year:年
			 * month:年月
			 * day:年月日
			 * hour:年月日小时
			 * minute:年月日小时分钟
			 * second:年月日小时分钟秒
			 */
			type: {
				type: String as PropType<ModelType>,
				default: "day"
			},
			/**
			 * 输出时间格式，只对v-model:modelStr及输入框展示有效YYYY-MM-DD，为空时由当前语文决定
			 * 因此它可能不是一个标准时间，比如YY SS ,所以不能作为modelValue使用
			 * 有效格式：
			 * YYYY年
			 * MM月
			 * DD日
			 * hh小时
			 * mm分钟
			 * ss秒
			 */
			format: {
				type: String,
				default: ""
			},
			/**
			 * 上方的单位名称
			 * 默认为：['年', '月', '日', '时', '分', '秒']
			 */
			cellUnits: {
				type: Array as PropType<string[]>,
				default: () : string[] => [] as string[]
			},
			/**
			 * 快速时间区间选择，如果直接填写数字字符，会以你提供的数字最近多少来天来算。
			 * d:本日
			 * w:本周
			 * m:本月
			 * y:本年
			 * q:本季度
			 * 7:最近7天，后面的依此类推，数字的就是最近xx天。
			 * px:前x年，p+[x]数字依此类推，表示前x年,如：p1,p2...
			 * 如果提供以下json结构，则以你自定的为准。
			 * UTSJSONObject:{title:'本学年',start:'2025-1-1',end:'2025-12-31'} as UTSJSONObject
			 */
			quickDate: {
				type: Array as PropType<Array<any>>,
				default: () : Array<any> => ['d', 'w', 'm', 'y', 'q'] as Array<any>
			},
			/**
			 * 是否懒加载内部内容。
			 * 当前你的列表内容非常多，且影响打开的动画性能时，请务必
			 * 设置此项为true，以获得流畅视觉效果。如果选择数据较少没有必要打开
			 * 要兼容微信,必须设置为true,非微信可以为false
			 */
			lazyContent: {
				type: Boolean,
				default: true
			},
			/**
			 * 如果你的快捷选择较多可能会让高度不足，需要自行设置下高。
			 */
			drawerSize: {
				type: String,
				default: '540px'
			},
			/**
			 * 是否禁用清除按钮，默认不禁用，允许用户清空选择。点确认，以清空选项数据
			 */
			disabledClear:{
				type:Boolean,
				default:false
			},
			/**
			 * 是否禁用弹出
			 */
			disabled:{
				type: Boolean,
				default: false
			},
			/**
			 * 宽屏时是否让内容剧中显示
			 * 并限制其宽为屏幕宽，只展示中间内容以适应宽屏。
			 */
			widthCoverCenter: {
				type: Boolean,
				default: true
			}
		},
		computed: {
			_lazyContent() : boolean {
				return this.lazyContent
			},
			_disabledClear() : boolean {
				return this.disabledClear
			},
			_start_date() : xDate {
				if (this.start == "") return this.startDate

				return new xDate(this.start)
			},
			_end_date() : xDate {
				if (this.end == "") return this.endDate
				return new xDate(this.end)
			},
			_start_date_str() : string {
				return this._start_date.format()
			},
			_end_date_str() : string {
				return this._end_date.format()
			},
			_start_date_str_format() : string {
				// '开始时间'
				if (this.nowValue[0] == '') return xConfig.i18n.t("tmui4x.betweentTime.start")
				// const date = (new xDate(this.nowValue[0])).format(this.format);
				if(this.format!=''){
					return (new xDate(this.nowValue[0])).format(this.format);
				}
				return xConfig.i18n.d(this.nowValue[0],null,{year:"numeric",month:"numeric",day:"numeric"} as DateTimeFormatOrNull)
			},
			_end_date_str_format() : string {
				// '结束时间'
				if (this.nowValue[1] == '') return xConfig.i18n.t("tmui4x.betweentTime.end")
				// (new xDate(this.nowValue[1])).format(this.format) 
				if(this.format!=''){
					return (new xDate(this.nowValue[1])).format(this.format) 
				}
				return xConfig.i18n.d(this.nowValue[1],null,{year:"numeric",month:"numeric",day:"numeric"} as DateTimeFormatOrNull)
			},
			_backgroundColor() : string {
				if (xConfig.dark == 'dark') {
					return getDefaultColor(xConfig.inputDarkColor)
				}
				return getDefaultColor('#f5f5f5')
			},
			_borderColor() : string {
				if (xConfig.dark == 'dark') {
					return getDefaultColor(xConfig.borderDarkColor)
				}
				return getDefaultColor('#eaeaea')
			},
			_activeBorderColor() : string {
				return getDefaultColor(xConfig.color)
			},
			_placeStyle() : string {
				if (xConfig.dark == 'dark') {
					return "color:#c7c7c7;"
				}
				return "color:#838383;"
			},
			_fontColor() : string {
				if (xConfig.dark == 'dark') {
					return "#efefef"
				}
				return "#333"
			},
			_isDark() : boolean {
				return xConfig.dark == 'dark'
			},
			_checkPass():boolean{
				return  this.nowValue.some((el:string):boolean=>el=='');
			},
			_disabled():boolean{
				return this.disabled
			},
			_cellUnits():string[]{
				if(this.cellUnits.length==0){
					
					return [
						xConfig.i18n.t("tmui4x.pickerDate.year"),
						xConfig.i18n.t("tmui4x.pickerDate.month"),
						xConfig.i18n.t("tmui4x.pickerDate.day"),
						xConfig.i18n.t("tmui4x.pickerDate.hour"),
						xConfig.i18n.t("tmui4x.pickerDate.minute"),
						xConfig.i18n.t("tmui4x.pickerDate.second"),
					]
				}
				return this.cellUnits;
			}

		},
		watch: {
			
			modelValue(newvalue : string[]) {
				let sortvalue = this.sorDateVaild(this.validTimeDate(newvalue))
				let newvaluestr = sortvalue.join('');
				if (newvaluestr == this.nowModelValue.join('')) return;
				this.nowValue = sortvalue;
				this.nowModelValue = sortvalue;
				this.tongbuModelStr()
				this.quicklistSelectedStr = ''
			},
			modelShow(newValue : boolean) {
				if (newValue == this.show) return;
				this.show = newValue
			},
			quickDate(newvalue : string[]) {
				this.quicklist = this.getQuickDateType()
			}
		},

		mounted() {
			this.yanchiDuration = this._lazyContent ? false : true

			let str = this.validTimeDate(this.modelValue)
			this.nowValue = str;
			this.nowModelValue = str;
			this.quicklist = this.getQuickDateType()
			this.tongbuModelStr()
		},
		methods: {
			
			clearDate(){
				let dst = ['',''] as string[]
				this.nowValue = dst
				
			},
			tongbuModelStr(){
				let str = this.coverStrVal()
				/**
				 * 经格式化后的值。等同v-model:model-str
				 */
				this.$emit('update:modelStr', str == '~' ? '' : str);
			},
			dateChangeView(datestr : string) {
				clearTimeout(this.tid)
				let _this = this;
				this.tid = setTimeout(function() {
					_this.quicklistSelectedStr = ''
					let nowvalu = _this.nowValue.slice(0)
					nowvalu[_this.changeIndex] = datestr;
					let strStart = nowvalu[0]
					let strEnd = nowvalu[1]
					
					let types = _this.getTypes()
					if (strEnd != '' && strStart != '') {
						if (_this.changeIndex == 0) {
							if (new xDate(strStart).isBetweenOf(new xDate(strEnd), '>', types)) {
								strEnd = strStart
							}
						} else if (_this.changeIndex == 1) {
							if (new xDate(strEnd).isBetweenOf(new xDate(strStart), '<', types)) {
								
								strStart = strEnd
							}
						}
					}
					
					_this.nowValue = [strStart, strEnd]
					_this.$forceUpdate()
				}, 50);
				
			},
			tagsClick(item : coverValueType) {
				this.nowValue = item.value
				this.quicklistSelectedStr = item.str
		
				this.$emit('dateClick',{text:item.str,value:item.value.slice(0)} as UTSJSONObject)
			},
			inputClick(index : number) {
				this.changeIndex = index;

				let nowvalu = this.nowValue.slice(0)
				let strStart = nowvalu[0]
				let strEnd = nowvalu[1]

				if (this.changeIndex == 0) {
					if (strStart == '') {
						// strStart = strEnd != '' ? strEnd : (this.endDate.format())
						let tempStart = new xDate().getBetweenDate(this._start_date_str,this._end_date_str,'max')
						strStart = new xDate(tempStart).format()
						this.nowValue = [strStart, strEnd]
					}
				} else if (this.changeIndex == 1) {
					if (strEnd == '') {
						// strEnd = strStart != '' ? strStart : (this.endDate.format())
						let tempEnd = new xDate().getBetweenDate(this._start_date_str,this._end_date_str,'max')
						strEnd = new xDate(tempEnd).format()
						this.nowValue = [strStart, strEnd]
					}
				}


			},

			getQuickDateType() : coverValueType[] {
				let typelist = [] as coverValueType[];
				let list:Array<any> = this.quickDate;
				if (list.length == 0) return typelist;
				let _date = new xDate()
				let startFDate = "YYYY/MM/DD 00:00:00"
				let endFDate = "YYYY/MM/DD 23:59:59"
				let _start = new xDate(new xDate().getBetweenDate(this._start_date_str,this._end_date_str,'min')).format(startFDate)
				let _end = new xDate(new xDate().getBetweenDate(this._start_date_str,this._end_date_str,'max')).format(endFDate)
				_date = new xDate(_start)
				for (let i = 0; i < list.length; i++) {
					let item : any = list[i];
					
					if(typeof item == 'string'){
						if(item.substring(0,1)=='p'){
							let dshi = parseInt(item.substring(1))! as number
							let date = _date.getClone()
							let start = _start
							date.subtraction(dshi, 'y')
							date = new xDate(date.getBetweenDate(this._start_date_str,this._end_date_str,'min'))
							let end = date.format()
							// '前' + dshi + '年'
							typelist.push({ value: [end, start], str: xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle3",dshi) } as coverValueType)
						}else if (!isNaN(parseInt(item))) {
							let dshi = parseInt(item)! as number;
							let date = _date.getClone()
							let start = _start
							date.subtraction(dshi, 'd')
							date = new xDate(date.getBetweenDate(this._start_date_str,this._end_date_str,'min'))
							let end = date.format()
							// '最近' + item + '天'
							typelist.push({ value: [end, start], str: xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle2",dshi) } as coverValueType)
						} else {
							let dshi = 0;
							let date = new xDate(_end)
							let startFDate = "YYYY/MM/DD 00:00:00"
							let endFDate = "YYYY/MM/DD 23:59:59"
							let start = date.format(startFDate)
							let end = date.format(endFDate)
							
							// "本日"
							let desc = xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle",0)
							if (item == 'w') {
								start = date.getDateStartOf('w').format(startFDate)
								end = date.getDateEndOf('w').format(endFDate)
								start = new xDate(new xDate(start).getBetweenDate(this._start_date_str,this._end_date_str,'min')).format(startFDate)
								end = new xDate(new xDate(end).getBetweenDate(this._start_date_str,this._end_date_str,'max')).format(endFDate)
								desc = xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle",1);//"本周"
							} else if (item == 'm') {
								start = date.getDateStartOf('m').format(startFDate)
								end = date.getDateEndOf('m').format(endFDate)
								start = new xDate(new xDate(start).getBetweenDate(this._start_date_str,this._end_date_str,'min')).format(startFDate)
								end = new xDate(new xDate(end).getBetweenDate(this._start_date_str,this._end_date_str,'max')).format(endFDate)
								desc = xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle",2);//"本月"
							} else if (item == 'y') {
								start = date.getDateStartOf('y').format(startFDate)
								end = date.getDateEndOf('y').format(endFDate)
								start = new xDate(new xDate(start).getBetweenDate(this._start_date_str,this._end_date_str,'min')).format(startFDate)
								end = new xDate(new xDate(end).getBetweenDate(this._start_date_str,this._end_date_str,'max')).format(endFDate)
								desc = xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle",3);//"本年"
							} else if (item == 'q') {
								let nowq = date.getQuarter('')
								let itemqatar = nowq[0]
								start = itemqatar.start
								end = itemqatar.end
								start = new xDate(new xDate(start).getBetweenDate(this._start_date_str,this._end_date_str,'min')).format(startFDate)
								end = new xDate(new xDate(end).getBetweenDate(this._start_date_str,this._end_date_str,'max')).format(endFDate)
								desc = xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle",4);//"本季度"
							}
										
							typelist.push({ value: [start, end], str: desc } as coverValueType)
						}
					}else if(typeof item == 'number'){
						let dshi = item as number;
						let date = _date.getClone()
						let start = _start
						date.subtraction(dshi, 'd')
						date = new xDate(date.getBetweenDate(this._start_date_str,this._end_date_str,'min'))
						let end = date.format()
						// '最近' + item + '天'
						typelist.push({ value: [end, start], str: xConfig.i18n.t("tmui4x.betweentTime.quiakListTitle2",dshi) } as coverValueType)
					}
					
					else if(item instanceof UTSJSONObject){
						let title = item.getString('title')
						let v_start = item.getString('start')
						let v_end = item.getString('end')
						if(title!=null&&v_start!=null&&v_end!=null){
							typelist.push({ value: [v_start, v_end], str: title } as coverValueType)
						}
					}
					
				}
				
				return typelist;
			},
			// 获取精确单位
			getTypes() : xDateTypeTime {
				type ModelType = "year" | "month" | "day" | "hour" | "minute" | "second";
				if (this.type == 'year') {
					return 'y' as xDateTypeTime
				} else if (this.type == 'month') {
					return 'm' as xDateTypeTime
				} else if (this.type == 'day') {
					return 'd' as xDateTypeTime
				} else if (this.type == 'hour') {
					return 'h' as xDateTypeTime
				} else if (this.type == 'minute') {
					return 'M' as xDateTypeTime
				} else if (this.type == 'second') {
					return 's' as xDateTypeTime
				}
				return 's' as xDateTypeTime
			},
			//验证提供的值是否合法，并纠正为合法值。
			validTimeDate(val : string[]) : string[] {
				// let defaulttime = new xDate().format()
				let str = ['', '']
				if (val.length >= 1) {
					str[0] = val[0]!
				}
				if (val.length >= 2) {
					str[1] = val[1]!
				}

				return this.sorDateVaild(str)
			},
			sorDateVaild(str : string[]) : string[] {
				let types = this.getTypes()
				str.sort((a : string, b : string) : number => {
					return new xDate(a).getTime(types) - new xDate(b).getTime(types)
				})
				return str;
			},

			openShow() {
				if(this._disabled) return;
				this.show = true;
				/**
				 * 变量控制打开状态
				 * 等同v-model:model-show
				 */
				this.$emit('update:modelShow', true)

			},
			onClose() {
				/**
				 * 变量控制打开状态
				 * 等同v-model:model-show
				 */
				this.$emit('update:modelShow', false)
				this.cancelResetDataCol()
				if (this._lazyContent) {
					this.yanchiDuration = false
				}
			},
			onOpen() {
				this.yanchiDuration = true
			},
			onCancel() {
				this.$emit('cancel')
				this.cancelResetDataCol()
			},
			cancelResetDataCol() {
				this.nowValue = this.nowModelValue.slice(0)
			},
			coverStrVal() : string {
				let estrt = this.nowValue[0];
				let eend = this.nowValue[1];
				let start = estrt == '' ? '' : (new xDate(estrt)).format(this.format)
				let ebd = eend == '' ? '' : (new xDate(eend)).format(this.format)
				return start + '~' + ebd
			},
			onConfirm() {
				let nowval = this.nowModelValue.slice(0)
				
				
				let str = this.coverStrVal()
				let tmdate = [] as string[];
				if(this.nowValue[0]!=''&&this.nowValue[1]!=''){
					tmdate = this.nowValue.slice(0)
					this.nowModelValue = tmdate
				}
				/**
				 * 点击确认时同步。等同v-model
				 */
				this.$emit('update:modelValue', tmdate);

				/**
				 * 经格式化后的值。等同v-model:model-str
				 */
				this.$emit('update:modelStr', str == '~' ? '' : str);

				this.$emit('confirm', tmdate);

			}
		},
	}
</script>
<template>
	<view @click="openShow">
		<!--
		 @slot 插槽,默认触发打开选择器。你的默认布局可以放置在这里。
		 @prop {boolean} show - 控制打开关闭状态
		 -->
		<slot></slot>
	</view>
	<x-drawer :disabledConfirm="_checkPass&&_disabledClear" @open="onOpen" :widthCoverCenter="widthCoverCenter" :disabledScroll="true" @close="onClose"
		@confirm="onConfirm" @cancel="onCancel" :showFooter="true" v-model:show="show"
		:size="drawerSize" :showClose="false">
		<template v-slot:title>
			<view class="xPickerClear" :style="{height:'50px'}">
				<x-text>{{title!=''?title:i18n!.t("tmui4x.betweentTime.title")}}</x-text>
				<!-- 清空 -->
				<x-text v-if="!_disabledClear" @click="clearDate" style="opacity: 0.5;">{{i18n!.t("tmui4x.clear")}}</x-text>
			</view>
		</template>
		<view class="xPickerDateWrap">
			<view v-if="quicklist.length>0" class="xPickerDateWrapQuickTags">
				<x-tag font-size="14" :font-color="(_isDark?'white':'')" @click="tagsClick(item)" :skin='quicklistSelectedStr==item.str?"normal":"thin"' :round="8" size="large"
					style="margin-right:10px;margin-bottom: 5px;" v-for="(item,index) in quicklist" :key="index">{{item.str}}</x-tag>
			</view>

			<x-divider></x-divider>
			<view style="height: 8px;"></view>
			
			<view class="xPickerDateWrapQuickInput">
				<view  class="xPickerInputMaskerParent" @click="inputClick(0)" :style="{flex:'1',height:'40px'}">
					<input :placeholder-style="_placeStyle"
						:style="{color:changeIndex==0?_activeBorderColor:_fontColor,
						border: `2px solid ${changeIndex==0?_activeBorderColor:_backgroundColor}`,
						backgroundColor:_backgroundColor,
						fontSize:'16px'
						}"
						class="xPickerInput" :value="_start_date_str_format" />
						<view class="xPickerInputMasker"></view>
				</view>
				<!-- 至 -->
				<x-text style="width: 64px;text-align: center;">
					{{i18n!.t("tmui4x.betweentTime.splite")}}
				</x-text>
				<view class="xPickerInputMaskerParent" @click="inputClick(1)" :style="{flex:'1',height:'40px'}">
					<input :placeholder-style="_placeStyle"
						:style="{color:changeIndex==1?_activeBorderColor:_fontColor,
						border: `2px solid ${changeIndex==1?_activeBorderColor:_backgroundColor}`,
						backgroundColor:_backgroundColor,
						fontSize:'16px'
						}"
						class="xPickerInput" :value="_end_date_str_format" />
						<view class="xPickerInputMasker"></view>
				</view>
			</view>
			<x-divider style="margin-bottom: 8px;"></x-divider>
			<x-date-view v-if="yanchiDuration"  @change="dateChangeView" :format="format" :type="type" :cell-units="_cellUnits"
				:start="_start_date_str" :end="_end_date_str" :model-value='nowValue[changeIndex]'></x-date-view>
		</view>
		<x-loading v-if="!yanchiDuration"></x-loading>
	</x-drawer>
</template>
<style scoped>
	.xPickerClear{
		padding: 0 20px;
		/* height:50px; */
		display: flex;flex-direction: row;
		justify-content: space-between;
		align-items: center;
	}
	.xPickerDateText {
		text-align: left;
		transition-duration: 350ms;
		transition-timing-function: linear;
		transition-property: transform, opacity;
		transform: translateY(100%) scale(0);
		opacity: 0;

	}

	.xPickerDateWrapQuickInputPlackeTips {
		flex: 1;
		display: flex;
		flex-direction: row;
		pointer-events: none;
	}
	.xPickerInputMaskerParent{
		position: relative;
	}
	.xPickerInputMasker{
		position: absolute;
		width:100%;
		height:100%;
	}
	.xPickerInput {
		border-radius: 40px;
		height: 100%;
		padding: 0 10px;
		/* font-size: 16px; */
		flex: 1;
		pointer-events: none;
		text-align: center;
	}

	.xPickerDateWrapQuickInput {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 8px;
	}

	.xPickerDateWrapQuickTags {
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
		margin-bottom: 8px;
	}

	.xPickerDateWrap {}
</style>