type callbackFunType = (x:number)=>number
let kSplineTableSize = 11;
let kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

function A(aA1:number, aA2:number):number { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
function B(aA1:number, aA2:number):number { return 3.0 * aA2 - 6.0 * aA1 }
function C(aA1:number):number { return 3.0 * aA1 }

function calcBezier(aT:number, aA1:number, aA2:number):number { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
function getSlope(aT:number, aA1:number, aA2:number):number { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

function binarySubdivide(aX:number, aA:number, aB:number, mX1:number, mX2:number):number {
	let currentX = 0;
	let currentT = 0;
	let i = 0;
	do {
		currentT = aA + (aB - aA) / 2.0;
		currentX = calcBezier(currentT, mX1, mX2) - aX;
		if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
	} while (Math.abs(currentX) > 0.0000001 && ++i < 10);
	return currentT;
}

function newtonRaphsonIterate(aX:number, aGuessT:number, mX1:number, mX2:number):number {
	let pat = aGuessT;
	for (let i = 0; i < 4; ++i) {
		let currentSlope = getSlope(aGuessT, mX1, mX2);
		if (currentSlope == 0.0) { return aGuessT; }
		let currentX = calcBezier(aGuessT, mX1, mX2) - aX;
		pat -= currentX / currentSlope;
	}
	return pat;
}

function bezier(mX1:number, mY1:number, mX2:number, mY2:number):callbackFunType|null {

	if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return null; }
	let sampleValues:number[] = [];

	if (mX1 != mY1 || mX2 != mY2) {
		for (let i = 0; i < kSplineTableSize; ++i) {
			sampleValues.push(calcBezier(i * kSampleStepSize, mX1, mX2))
		}
	}

	function getTForX(aX:number):number {

		let intervalStart = 0;
		let currentSample = 1;
		let lastSample = kSplineTableSize - 1;

		for (; currentSample != lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
			intervalStart += kSampleStepSize;
		}

		--currentSample;

		let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
		let guessForT:number = intervalStart + dist * kSampleStepSize;
		let initialSlope = getSlope(guessForT, mX1, mX2);

		if (initialSlope >= 0.001) {
			return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
		} else if (initialSlope == 0.0) {
			return guessForT;
		}
		return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	}

	return function (x:number):number {
		if (mX1 == mY1 && mX2 == mY2) { return x; }
		if (x == 0 || x == 1) { return x; }
		return calcBezier(getTForX(x), mY1, mY2);
	}

}

export default bezier