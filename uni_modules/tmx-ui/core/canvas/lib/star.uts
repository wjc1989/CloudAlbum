import { Shape } from './shape.uts';
import { CanvasRotateCenter, IShapeBoundRect, IShapeOptional } from '../interface.uts';
import { ICanvas } from '@/uni_modules/tmx-ui/core/canvas/ICanvas.uts';

export class IStar extends Shape {
	override type = 'IStar'
	constructor(config: IShapeOptional, canvas: ICanvas) {
		super(config, canvas);
		this.numPoints = config?.numPoints ?? 5;
		this.innerRadius = config?.innerRadius ?? 16;
		this.outerRadius = config?.outerRadius ?? 30;
		this.width = this.outerRadius * 2;
		this.height = this.outerRadius * 2;
	}

	setInnerRadius(value: number): IStar {
		this.innerRadius = value;
		this.needsUpdate = true;
		return this;
	}

	setOuterRadius(value: number): IStar {
		this.outerRadius = value;
		this.width = value * 2;
		this.height = value * 2;
		this.needsUpdate = true;
		return this;
	}

	setNumPoints(value: number): IStar {
		this.numPoints = value;
		this.needsUpdate = true;
		return this;
	}

	override getBoundRect(): IShapeBoundRect {
		const w = this.outerRadius * 2;
		return {
			x: this.x,
			y: this.y,
			width: w,
			height: w
		} as IShapeBoundRect;
	}

	override setWidth(value: number): IStar {
		this.height = value;
		this.width = value;
		this.outerRadius = value / 2;
		this.needsUpdate = true;
		return this;
	}

	override setHeight(value: number): IStar {
		this.height = value;
		this.width = value;
		this.outerRadius = value / 2;
		this.needsUpdate = true;
		return this;
	}

	override draw(ctx: CanvasRenderingContext2D) {
		if (this.visible == false) return;
		super.draw(ctx);
		ctx.beginPath();

		// 计算每个角的角度增量
		const angleStep = Math.PI * 2 / this.numPoints;
		// 起始角度（使星形垂直向上）
		const startAngle = -Math.PI / 2;

		// 绘制第一个点（外部点）
		let x = this.x + Math.cos(startAngle) * this.outerRadius;
		let y = this.y + Math.sin(startAngle) * this.outerRadius;
		ctx.moveTo(x, y);

		// 绘制其余的点
		for (let i = 1; i <= this.numPoints * 2; i++) {
			const angle = startAngle + angleStep * i / 2;
			const radius = i % 2 === 0 ? this.outerRadius : this.innerRadius;
			x = this.x + Math.cos(angle) * radius;
			y = this.y + Math.sin(angle) * radius;
			ctx.lineTo(x, y);
		}

		ctx.closePath();
		if (this.fill != "") {
			ctx.fill();
		}
		if (this.stroke != "") {
			ctx.stroke();
		}
		ctx.restore();
	}

	override isPointInPath(x: number, y: number, shapeId: string): boolean {
		if (!this.visible || (shapeId != "" && shapeId != this.id)) return false;

		// 计算点击位置相对于星形中心的实际坐标
		let realX = x - this.offsetX - this.x;
		let realY = y - this.offsetY - this.y;

		// 如果有旋转，需要将坐标转换回未旋转状态
		if (this.rotation != 0) {
			const angle = -this.rotation * Math.PI / 180;
			const cos = Math.cos(angle);
			const sin = Math.sin(angle);
			let centerX = 0;
			let centerY = 0;
			
			// 根据不同的旋转中心点设置centerX和centerY
			switch(this.rotateCenter) {
				case 'topLeft':
					centerX = 0;
					centerY = 0;
					break;
				case 'topRight':
					centerX = this.width;
					centerY = 0;
					break;
				case 'bottomLeft':
					centerX = 0;
					centerY = this.height;
					break;
				case 'bottomRight':
					centerX = this.width;
					centerY = this.height;
					break;
				case 'center':
				default:
					centerX = this.width/2;
					centerY = this.height/2;
					break;
			}
			const dx = realX - centerX;
			const dy = realY - centerY;
			realX = centerX + dx * cos - dy * sin;
			realY = centerY + dx * sin + dy * cos;
		}

		// 计算点到中心的距离
		const distance = Math.sqrt(realX * realX + realY * realY);

		// 如果点击位置超出外半径，则不在星形内
		if (distance > this.outerRadius * Math.max(this.scaleX, this.scaleY)) return false;

		// 计算点击位置的角度
		let angle = Math.atan2(realY, realX);
		if (angle < 0) angle += Math.PI * 2;

		// 调整角度使其从垂直向上开始计算
		angle = (angle + Math.PI / 2) % (Math.PI * 2);

		// 计算点所在的扇区
		const angleStep = Math.PI * 2 / this.numPoints;
		const sector = Math.floor(angle / angleStep);
		const sectorAngle = angle - sector * angleStep;

		// 计算该角度对应的半径
		const ratio = sectorAngle / angleStep;
		const radius = this.innerRadius + (this.outerRadius - this.innerRadius) * Math.abs(0.5 - ratio) * 2;
		// 考虑缩放因素
		const scaledRadius = radius * Math.max(this.scaleX, this.scaleY);
		// 如果点击位置在计算出的半径内，则在星形内
		return distance <= scaledRadius;
	}
}